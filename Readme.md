{-* 
  * Master Parisien de Recherche en Informatique 
  * Université Denis Diderot Paris 7 - 2010 - 2011
  * Projet de Haskell
  * Denis JULIEN  : julien@informatique.univ-paris-diderot.fr
  *
  *   Project : Huffman Zip in Haskell
  *
  * $Id: readme,v 1.1 2011/04/28 09:00:04 denis7cordas Exp $
  *
  * Contents : 
  *       Readme
  * History :
  *   DJ20110428 : creation
  *       
-}
{-
-- -----------------------------------------------------------------------------
I - Aim of this document :
--------------------------
This document is a short presentation of   hzip program which was the homework 
of the  Advanced Functional Programming Course ( more information at  
http://www.pps.jussieu.fr/~jch/enseignement/pfa/.). 
 The hzip program is an implementation in Haskell of  the Huffman compression 
file based on the specification  document that you will find at the following 
web page  http://www.pps.jussieu.fr/~jch/enseignement/pfa/huffman.pdf.

After a short overview of the main characteristics of the implementation you 
will find the source files directory with a short description.

-----------------------------
II - Implementation overview:
----------------------------- 
 A major constraint was to ensure the full compliance with the zip file  
generated by the reference C program provided by Juliusz Chroboczek. So the zip 
file resulting from hzip  is compliant with the reference  program and zip file 
generated can  be read and processed by this haskell program. 

We focus this implementation on the performance in three major points : 
1) perform efficient read and write of a binary file  
2) use a few memory and run in constant memory space  
3) optimize the global run time  

 The first point was reached in buffering the reading. In fact it is  the splitAt
call on the ByteString structure which performs the actually read. The best 
number of bytes to split has been evaluated by several tests the value is 
defined in the packetSize variable. 
The reader can find more information in the Hf_BitsFlow.hs source file.

 The second point was reached using a bitsFlow continuation mechanism which 
allows reading a very huge file without use very much memory.  Also to store the
 major data structure like CodingTable or WeightTable the Map haskell which is 
internally implemented with trees. So hzip uses less than 3 Mega bytes in RAM.

 For the third point, as we have to do for other program language, we optimized 
the function the more often called. We reached the target was to obtain the same
 time for compress than uncompress a file.  
 
 The result of program and function comparison in term of global run time is the
following table. The time was calculated using the unix time program on the 
Lucien machine. The program has been compiled by ghc with the optimization 
tag –O. 

  *          ____________________ __________________________ 
  *          |size = 20M/15M     |  compress  | uncompress | 
  *          |___________________|____________|____________| 
  *          |         C program |  6"        |  6"        | 
  *          |___________________|____________|____________| 
  *          |   Haskell program |  21"       |  20"       | 
  *          |___________________|____________|____________| 
  *          |size = 100M/75M    |  compress  | uncompress | 
  *          |___________________|____________|____________| 
  *          |Huffmann C program |  23"       |  28"       | 
  *          |___________________|____________|____________| 
  *          |Huffmann Haskell   |  128"      |  221"      | 
  *          |___________________|____________|____________| 
  *
        
 These figures show that the haskell program is five times slower than C program
 when it is compressing or uncompressing data in RAM.  But it is slower when it 
is writing on the hard disk. The time of the global uncompress processing is 
multiplied by 7.8. This difference dues to the size of the written data. The 
speed of the data transfer to the hard disk can be calculated by the following 
formula:  (delta file size) / (delta run time) 
so (100 - 20) / (221 - 20) = 80 / 201 ->  400 KB/s  
where we consider the process in RAM not relevant.
  
-----------------------------------      
III - How to generate hzip binary  : Use make on the provided MakeFile
-----------------------------------

-------------------
IV - Source files :  
-------------------
Hf_BitsFlow.hs  : Functions related to  BitsFlow
Hf_CarambarJokes : Sample of random function use.
Hf_CodingTable.hs : Functions to make and access the  Coding Table of Symbols
Hf_Compress.hs :  Main function to zip file
Hf_HuffmanTree.hs :  Functions related to huffman Tree read and construction from the zip file.
Hf_Io.hs : Parameters used to Files access.
Hf_Main.hs : Main function
Hf_ParseZipFile.hs : Analyze of Zip file call functions to read Huffman tree and to    uncompress.
Hf_PrivateBytes.hs :  Module can be used to use the memory space reserved into the  zip file.
Hf_RWZipFile.hs : Functions to read and write compressed file.
Hf_Types.hs : The basic types used in Huffman Haskell project.
Hf_Uncompress.hs : Main function to Unzip file
Hf_Utilities.hs : Set of little tools.
Hf_WeightTable.hs : Functions to symbol frequency computation.
Hf_WeightTree.hs : Functions related to Weight Tree.


